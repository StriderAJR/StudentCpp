# Локальные и глобальные переменные
Если кто-то изучал раньше Паскаль, то, возможно, поймет меня. Лично меня страшно бесило, что все переменные в этом языке нужно было объявлять в начале процедуры.

```Pascal
Procedure Example();
Var
  a, b, c : real;
begin
  a := 5.2;
  b := 2.1;
  c := a-b;
end ;
```

Каждый раз, когда ты понимаешь, что нужна еще одна переменная, нужно скроллить вверх, находить объявление переменных, добавлять туда переменную, возвращаться обратно и продолжать работу. И это притом, что процедура не всегда влезает в один экран! В общем, кошмар.

В С++ такого нет. Переменная может быть объявлена в любом месте программы. Причем считается правильным объявлять переменную как можно ближе к месту, где она будет использована.

Однако, согласитесь может возникнуть премерзкая ситуация:

```C++
bool flag = true;
int a;
if(flag)
{	
	int b;
	cin >> b; // Просим пользователя ввести с клавиатуры число b
	a = b*2;
}
else
{
	int b = 4;
	a = b/2;
}
```

Понятно, что этот алгоритм можно легко переписать правильно, и тогда двойного объявления переменной b можно избежать, но мне важно проиллюстрировать то, о чем сейчас пойдет речь.

У нас сейчас в одном алгоритме получилось, что объявлено 2 переменных с одним и тем же именем - b. Вроде бы, должна быть ошибка, потому что возникает неоднозначность, какая переменная b, где используется.

Логически мы понимаем, что в двух разных блоках кода - две разные переменные b. И это правильно. Чтобы избежать таких конфликтов в С++ тоже есть понятия, которые позволяют избежать таких неоднозначностей: локальная переменные и глобальные переменные.

## Глобальные переменные

Глобальные переменные доступны из любого места в модуле программы. (Т.к. с понятием модуля в языке С++ кто-то может быть пока что не знаком, считайте, что это тот файл, в котором вы пишете код, например, main.cpp)

```C++
int tmp = 5; // tmp - глобальная переменная

void Func()
{
	tmp = 0;
}

int main()
{
	tmp = tmp+100;
	Func();
	cout << tmp; // Выведется 0
}
```

Глобальные переменные в С++ объявляются вне всех функций. Например, в самом начале программы. И работать с такой переменной можно в любом месте программы, не взирая на границы блоков кода.

> Блок кода - код расположенный между символами '{' и '}'

Тогда возникает разумный вопрос: если глобальные переменные такие удобные, почему нельзя везде и всюду использовать именно их?

Дело в том, что в памяти программы глобальные переменные занимают свое особое пространство. И не всегда вы можете быть уверены, что это пространство безгранично. Но даже не это страшно в **бездумном** использовании глобальных переменных.

Самое плохое - это снижение читаемости и понятности кода. Когда вы используете глобальную переменную в программах сложнее "Hello, World!" вам становится сложно сказать, где и в какой момент меняется состояние этой переменной. Вы не контролируете уровни доступа до нее. Вы можете забыть, где меняется эта переменная, а потом долга искать, почему данные в памяти имеют такой странный вид. Все это сделало использование глобальных переменных нежелательным.

Глобальные переменные такой же инструмент языка программирования, как и многие другие. Нужно уметь применять это с умом! Но всегда, когда возможно обойтись без использования шлобальных переменных, не используйте их.

## Локальные переменные

В отличии от глобальных переменных локальные существуют только в рамках того блока кода, в котором они были объявлены.

```C++
void Func()
{ // <-- Начало блока кода фун-ции Func
	int c = 3;

	cout << a; // Ошибка: Идентификатор 'а' не найден
	cout << b; // Ошибка: Идентификатор 'b' не найден
	cout << c; // Ошибки не будет
} // <-- Конец блока кода фун-ции Func

int main()
{ // <-- Начало блока кода фун-ции main
	int a = 1;
	for(int i = 0; i < 10; i++)
	{ // <-- Начало блока кода цикла for
		int b = 2;
		b = b+1;

		cout << a; // Ошибки не будет
		cout << b; // Ошибки не будет
		cout << c; // Ошибка: Идентификатор 'с' не найден
		cout << i; // Ошибки не будет
	} // <-- Конец блока кода цикла for

	cout << a; // Ошибки не будет
	cout << b; // Ошибка: Идентификатор 'b' не найден
	cout << c; // Ошибка: Идентификатор 'с' не найден
	cout << i; // Ошибка: Идентификатор 'i' не найден
} // <-- Конец блока кода фун-ции main
```

**Переменная c** объявлена в фун-ции Func, поэтому существует только в рамках этой функции. Внутри функции main ее не существует, поэтому при попытке любого к ней обращения будет выдаваться ошибка.

**Переменная а** объявлена в фун-ции main и существует как в самой функции main, так и во всех дочерних блоках кода любой вложенности. Поэтому переменная а видна в любом месте функции main, в том числе внутри цикла for.

**Переменные b и i (!)** объявлены внутри цикла for. И да, переменная i является локальной переменной цикла for! Обе этих пермеенные существуют только в рамках цикла и после его завершения уже не существуют.

Разница между переменными i и b заключается в том, что переменная i создается один раз в начале цикла и существует на протяжение всех итераций этого цикла. В то время, как переменная b создается каждый раз на каждой итерации.

Поэтому на протяжение цикла, переменная i будет выводиться на экран как 0, 1, 2, 3, ..., 9, а переменная b все время будет выводиться на экран равное 2.

### Где хранятся локальные переменные

Еще важно помнить, что локальные переменные создаются в стеке программы. И стек ограничен в своем размере.

Архитектурно такое решение оправдано тем, что в стек легко добавлять переменные при их создании с помощью команды push и достаточно помнить, сколько переменных было создано в каждом блоке кода. Тогда доатсточно сделать нужно количество команд pop по завершении блока кода, и стек всегда будет чистым и опрятным, без мусора.

К тому же стек хранит все данные подряд в отличие от "кучи" - динамической памяти программы (о ней будет рассказываться в дальнейшем), а это позволяет исключить дефрагментацию памяти, а соотвественно более высокое быстродейтсвие при работе с этой памятью.